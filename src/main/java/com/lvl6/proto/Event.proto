//ALL REQUEST PROTOS SHOULD INCLUDE A MinimumUserProto AS REQUIRED that represents which client sent it/triggered it 

import "BoosterPackStuff.proto";
import "Chat.proto";
import "City.proto";
import "Clan.proto";
import "Info.proto";
import "Job.proto";
import "MonsterStuff.proto";
import "Quest.proto";
import "Structure.proto";
import "Task.proto";
import "User.proto";

package com.lvl6.proto;

option java_outer_classname = "EventProto";

message InAppPurchaseRequestProto {
	optional MinimumUserProto sender = 1;
	optional string receipt = 2;
	optional string localcents = 3;
	optional string localcurrency = 4;
	optional string locale = 5;
	optional string ipaddr = 6;
}

																						//DONE
message InAppPurchaseResponseProto {
	optional MinimumUserProto sender = 1;
	optional InAppPurchaseStatus status = 2;
	optional int32 diamondsGained = 3;
	optional int32 coinsGained = 4;
	
	optional string packageName = 5;
	optional double packagePrice = 6;
	
	optional string receipt = 7;
	
	enum InAppPurchaseStatus {
		SUCCESS = 1;
		FAIL = 2;
		DUPLICATE_RECEIPT = 3;
	}
}

//------------------------------------------------------------------------------------------



//in the future, put in neutral city elems?
																						//DONE
message RetrieveStaticDataRequestProto {
    optional MinimumUserProto sender = 1;
	repeated int32 structIds = 2;
	repeated int32 taskIds = 3;
	repeated int32 questIds = 4;
	repeated int32 cityIds = 5;
	repeated int32 monsterIds = 6;
	repeated int32 buildStructJobIds = 7;
	repeated int32 upgradeStructJobIds = 8;
}

																						//DONE
message RetrieveStaticDataResponseProto {
    optional MinimumUserProto sender = 1;
	repeated FullStructureProto structs = 2;
	repeated FullTaskProto tasks = 3;
	repeated FullQuestProto quests = 4;
	repeated FullCityProto cities = 5;
	repeated BuildStructJobProto buildStructJobs = 6;
	repeated UpgradeStructJobProto upgradeStructJobs = 7;
	
	optional RetrieveStaticDataStatus status = 8;
	
	enum RetrieveStaticDataStatus {
		SUCCESS = 1;
		SOME_FAIL = 2;
	}
	
}

//------------------------------------------------------------------------------------------
message EnableAPNSRequestProto {
	optional MinimumUserProto sender = 1;
	optional string deviceToken = 2;
}

																						//DONE
message EnableAPNSResponseProto {
	optional MinimumUserProto sender = 1;
	optional EnableAPNSStatus status = 2;
	
	enum EnableAPNSStatus {
		SUCCESS = 1;
		NOT_ENABLED = 2;
	}
}

//------------------------------------------------------------------------------------------

message ReferralCodeUsedResponseProto {
	optional MinimumUserProto sender = 1;
	optional MinimumUserProto referredPlayer = 2;
	optional int32 coinsGivenToReferrer = 3;
}

//------------------------------------------------------------------------------------------
																						//DONE
message LoadCityRequestProto {
     optional MinimumUserProto sender = 1;
     optional int32 cityId = 2;    
}

																						//DONE
message LoadCityResponseProto {
     optional MinimumUserProto sender = 1;
     optional LoadCityStatus status = 2;

	     //client shouldnt show bars if already at max city level
     repeated CityElementProto cityElements = 3;
     optional int32 cityId = 4;
     repeated FullUserQuestDataLargeProto inProgressUserQuestDataInCity = 5;
     
     enum LoadCityStatus {
     	SUCCESS = 1;
     	NOT_ACCESSIBLE_TO_USER = 2;
     	OTHER_FAIL = 3;
     }    
}

//------------------------------------------------------------------------------------------
																						//DONE
message PurgeClientStaticDataResponseProto {
     optional int32 senderId = 1;
}

																						//DONE
message SendAdminMessageResponseProto {
     optional int32 senderId = 1;
     optional string message = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveUsersForUserIdsRequestProto {
    optional MinimumUserProto sender = 1;
	repeated int32 requestedUserIds = 2;
}

																						//DONE
message RetrieveUsersForUserIdsResponseProto {
    optional MinimumUserProto sender = 1;
	repeated FullUserProto requestedUsers = 2;
}

//------------------------------------------------------------------------------------------

message EarnFreeDiamondsRequestProto {
	optional MinimumUserProto sender = 1;
	optional EarnFreeDiamondsType freeDiamondsType = 2;
	optional int64 clientTime = 3;
		
}

																						//DONE
message EarnFreeDiamondsResponseProto {
	optional MinimumUserProto sender = 1;
	optional EarnFreeDiamondsStatus status = 2;
	optional EarnFreeDiamondsType freeDiamondsType = 3;
	
	enum EarnFreeDiamondsStatus {
		SUCCESS = 1;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 2;
		METHOD_NOT_SUPPORTED = 3;
		OTHER_FAIL = 4;
	}
}


//------------------------------------------------------------------------------------------

message LogoutRequestProto {
	optional MinimumUserProto sender = 1;
}

//------------------------------------------------------------------------------------------
message RetrieveLeaderboardEventRankingsRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 eventId = 2;
	optional int32 afterThisRank = 3;
}

message RetrieveLeaderboardEventRankingsResponseProto {
	optional MinimumUserProto sender = 1;
	optional RetrieveLeaderboardStatus status = 2;
	optional int32 eventId = 3;
	optional int32 afterThisRank = 4;

	optional MinimumUserProtoWithLevelForLeaderboard retriever = 5;
	repeated MinimumUserProtoWithLevelForLeaderboard resultPlayers = 6;

	repeated FullUserProto fullUsers = 7;
	
	enum RetrieveLeaderboardStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

message SendGroupChatRequestProto {
	optional MinimumUserProto sender = 1;
	optional GroupChatScope scope = 2;
	optional string chatMessage = 3;
	optional int64 clientTime = 4;
}

message SendGroupChatResponseProto {
	optional MinimumUserProto sender = 1;
	optional SendGroupChatStatus status = 2;
	
	enum SendGroupChatStatus {
		SUCCESS = 1;
		TOO_LONG = 2;
		OTHER_FAIL = 3;
		BANNED = 4;
	}
}

message ReceivedGroupChatResponseProto {
	optional MinimumUserProto sender = 1;
	optional string chatMessage = 2;
	optional GroupChatScope scope = 3;
	optional bool isAdmin = 4;
}

//------------------------------------------------------------------------------------------

//DONE
message CreateClanRequestProto {
	optional MinimumUserProto sender = 1;
	optional string name = 2;
	optional string tag = 3;
	optional bool requestToJoinClanRequired = 4;
	optional string description = 5;
}

message CreateClanResponseProto {
	optional MinimumUserProto sender = 1;
	optional CreateClanStatus status = 2;
	optional MinimumClanProto clanInfo = 3;
	
	enum CreateClanStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		NOT_ENOUGH_DIAMONDS = 3;
		NAME_TAKEN = 4;
		ALREADY_IN_CLAN = 5;
		INVALID_TAG_LENGTH = 6;
		TAG_TAKEN = 7;
	}	
}

//------------------------------------------------------------------------------------------

//if no newOwner set, assume wanting to delete
message LeaveClanRequestProto {
	optional MinimumUserProto sender = 1;
}

message LeaveClanResponseProto {
	optional MinimumUserProto sender = 1;
	optional LeaveClanStatus status = 2;
	
	enum LeaveClanStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		NOT_IN_CLAN = 3;
		OWNER_OF_CLAN_WITH_OTHERS_STILL_IN = 4;
	}	
}

//------------------------------------------------------------------------------------------

message RequestJoinClanRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 clanId = 2;
}

//since clanless user can directly join open clan,
//two successes: request_success, join_success
message RequestJoinClanResponseProto {
	optional MinimumUserProto sender = 1;
	optional RequestJoinClanStatus status = 2;
	optional int32 clanId = 3;
	optional MinimumUserProtoForClans requester = 4;
	optional MinimumClanProto minClan = 5;
	optional FullClanProtoWithClanSize fullClan = 6;
	
	enum RequestJoinClanStatus {
		REQUEST_SUCCESS = 1;
		OTHER_FAIL = 2;
		ALREADY_IN_CLAN = 3;
		REQUEST_ALREADY_FILED = 4;
		JOIN_SUCCESS = 5;
		CLAN_IS_FULL = 6;
	}	
}

//------------------------------------------------------------------------------------------

message RetractRequestJoinClanRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 clanId = 2;
}

message RetractRequestJoinClanResponseProto {
	optional MinimumUserProto sender = 1;
	optional RetractRequestJoinClanStatus status = 2;
	optional int32 clanId = 3;
	
	enum RetractRequestJoinClanStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		ALREADY_IN_CLAN = 3;
		DID_NOT_REQUEST = 4;
	}	
}	

//------------------------------------------------------------------------------------------

//can request as many as you like. wipe out other ones
message ApproveOrRejectRequestToJoinClanRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 requesterId = 2;
	optional bool accept = 3;
}

message ApproveOrRejectRequestToJoinClanResponseProto {
	optional MinimumUserProto sender = 1;
	optional ApproveOrRejectRequestToJoinClanStatus status = 2;
	optional int32 requesterId = 3;
	optional bool accept = 4;
	optional MinimumClanProto minClan = 5;
	optional FullClanProtoWithClanSize fullClan = 6;
	
	enum ApproveOrRejectRequestToJoinClanStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		NOT_OWNER = 3;
		NOT_A_REQUESTER = 4;
		ALREADY_IN_A_CLAN = 5;
	}	
}

//------------------------------------------------------------------------------------------

message RetrieveClanInfoRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 clanId = 2;
	optional string clanName = 3;
	optional ClanInfoGrabType grabType = 4;
	optional int32 beforeThisClanId = 5;
	optional bool isForBrowsingList = 6;
	
	enum ClanInfoGrabType {
		ALL = 1;
		CLAN_INFO = 2;
		MEMBERS = 3;
	}

}

message RetrieveClanInfoResponseProto {
	optional MinimumUserProto sender = 1;
	repeated MinimumUserProtoForClans members = 2;
	repeated FullClanProtoWithClanSize clanInfo = 3;
	optional RetrieveClanInfoStatus status = 4;
	optional bool isForSearch = 5;
	optional bool isForBrowsingList = 6;
	optional int32 clanId = 7;
	optional string clanName = 8;
	optional int32 beforeThisClanId = 9;
	
	
	enum RetrieveClanInfoStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
	}	
}

//------------------------------------------------------------------------------------------

message TransferClanOwnershipRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 newClanOwnerId = 2;
}

message TransferClanOwnershipResponseProto {
	optional MinimumUserProto sender = 1;
	optional TransferClanOwnershipStatus status = 2;
	optional MinimumClanProto minClan = 3;
	optional FullClanProtoWithClanSize fullClan = 4;
	
	enum TransferClanOwnershipStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		NOT_OWNER = 3;
		NEW_OWNER_NOT_IN_CLAN = 4;
	}	
}

//------------------------------------------------------------------------------------------

message ChangeClanDescriptionRequestProto {
	optional MinimumUserProto sender = 1;
	optional string description = 2;
}

message ChangeClanDescriptionResponseProto {
	optional MinimumUserProto sender = 1;
	optional ChangeClanDescriptionStatus status = 2;
	optional MinimumClanProto minClan = 3;
	optional FullClanProtoWithClanSize fullClan = 4;
	
	
	enum ChangeClanDescriptionStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		TOO_LONG = 3;
		NOT_IN_CLAN = 4;
		NOT_OWNER = 5;
	}	
}

//------------------------------------------------------------------------------------------

message BootPlayerFromClanRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 playerToBoot = 2;
}

message BootPlayerFromClanResponseProto {
     optional MinimumUserProto sender = 1;
	 optional int32 playerToBoot = 2;
	 optional BootPlayerFromClanStatus status = 3;
     
     enum BootPlayerFromClanStatus {
     	SUCCESS = 1;
     	OTHER_FAIL = 2;
     	NOT_OWNER_OF_CLAN = 3;
     	BOOTED_NOT_IN_CLAN = 4;
     }
}

//------------------------------------------------------------------------------------------

message GeneralNotificationResponseProto {
	optional string title = 1;
	optional string subtitle = 2;
	optional ColorProto rgb = 3;
}

message SubmitMonsterEnhancementRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 enhancingUserMonsterId = 2;
	repeated int64 feederUserMonsterIds = 3;
	optional int64 clientTime = 4;
}

message SubmitMonsterEnhancementResponseProto {
	optional MinimumUserProto sender = 1;
	optional EnhanceMonsterStatus status = 2;
	

	enum EnhanceMonsterStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 3;
		MAIN_OR_FEEDER_OR_EQUIPS_NONEXISTENT = 4;
		TRYING_TO_SURPASS_MAX_LEVEL = 5;
		NOT_ENOUGH_SILVER = 6;
	}
}



//requesting all booster packs and related booster items
message RetrieveBoosterPackRequestProto {
     optional MinimumUserProto sender = 1;
}

message RetrieveBoosterPackResponseProto {
	optional MinimumUserProto sender = 1;
	repeated BoosterPackProto packs = 2;
	optional RetrieveBoosterPackStatus status = 3;
	
	enum RetrieveBoosterPackStatus {
     	SUCCESS = 1;
     	SOME_FAIL = 2;
     }
}

message PurchaseBoosterPackRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 boosterPackId = 2;
	optional int64 clientTime = 3; 
}

message PurchaseBoosterPackResponseProto {
	optional MinimumUserProto sender = 1;
	optional PurchaseBoosterPackStatus status = 2;
	
	enum PurchaseBoosterPackStatus {
		SUCCESS = 1;
		NOT_ENOUGH_GOLD = 2;
		NOT_ENOUGH_SILVER = 3;
		OTHER_FAIL = 4;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 5;
	}
}

message ReceivedRareBoosterPurchaseResponseProto {
	optional RareBoosterPurchaseProto rareBoosterPurchase = 1;
}

//------------------------------------------------------------------------------------

message ChangeClanJoinTypeRequestProto {
	//from an open (no request to join necessary) to request to join necessary
	optional MinimumUserProto sender = 1;
	optional bool requestToJoinRequired = 2;
}

message ChangeClanJoinTypeResponseProto {
	optional MinimumUserProto sender = 1;
	optional ChangeClanJoinTypeStatus status = 2;
	optional MinimumClanProto minClan = 3;
	optional FullClanProtoWithClanSize fullClan = 4;
	
	enum ChangeClanJoinTypeStatus {
		SUCCESS = 1;
		OTHER_FAIL = 2;
		NOT_IN_CLAN = 3;
		NOT_OWNER = 4;
	}
}

//------------------------------------------------------------------------------------

message PrivateChatPostRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 recipientId = 2;
	optional string content = 3;
}

																						//DONE
message PrivateChatPostResponseProto {
	 optional MinimumUserProto sender = 1;
     optional PrivateChatPostStatus status = 2;
	 optional PrivateChatPostProto post = 3;
	
     enum PrivateChatPostStatus {
     	SUCCESS = 1;
     	NO_CONTENT_SENT = 2;
     	POST_TOO_LARGE = 3;
     	OTHER_FAIL = 4;
     	BANNED = 5;
	}
}

message RetrievePrivateChatPostsRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 otherUserId = 2;
	
	//all prior posts not including this id
	//if this is not set then return most recent ones
	optional int32 beforePrivateChatId = 3;
	
}

message RetrievePrivateChatPostsResponseProto {
	optional MinimumUserProto sender = 1;
	repeated GroupChatMessageProto posts = 2;
	optional int32 beforePrivateChatId = 3;
	optional RetrievePrivateChatPostsStatus status = 4;
	optional int32 otherUserId = 5;

	enum RetrievePrivateChatPostsStatus {
		SUCCESS = 1;
		FAIL = 2;
	}	
}

//------------------------------------------------------------------------------------

message BeginDungeonRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 clientTime = 2;
	optional int32 taskId = 3; 
}

message BeginDungeonResponseProto {
	optional MinimumUserProto sender = 1;
	repeated TaskStageProto tsp = 2;
	optional int64 userTaskId = 3;
	optional BeginDungeonStatus status = 4;
	
	enum BeginDungeonStatus {
		SUCCESS = 1;
		FAIL_INSUFFICIENT_STAMERGY = 2;
		FAIL_OTHER = 3;
	}
}

message EndDungeonRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 userTaskId = 2;
	optional bool userWon = 3; 
	optional int64 clientTime = 4;
}

message EndDungeonResponseProto {
	optional MinimumUserProto sender = 1;
	optional EndDungeonStatus status = 2;
	
	
	enum EndDungeonStatus {
		SUCCESS = 1;
		FAIL_OTHER = 2;
	}
}

message ReviveInDungeonRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 userTaskId = 2;
	optional int64 clientTime = 3; //tracking purposes 
}

message ReviveInDungeonResponseProto {
	optional MinimumUserProto sender = 1;
	optional ReviveInDungeonStatus status = 2;
	
	enum ReviveInDungeonStatus {
		SUCCESS = 1;
		FAIL_INSUFFICIENT_FUNDS = 2;
		FAIL_OTHER = 3;
	}
}

//mainly used during battle
message UpdateMonsterDurabilityRequestProto {
	optional MinimumUserProto sender = 1;
	repeated FullUserMonsterProto fueps = 2; //contains new durabilities 
	optional int64 clientTime = 3; //history, tracking purposes
}

message UpdateMonsterDurabilityResponseProto {
	optional MinimumUserProto sender = 1;
	repeated FullUserMonsterProto fueps = 2;
	optional UpdateMonsterDurabilityStatus status = 3;
	
	enum UpdateMonsterDurabilityStatus {
		SUCCESS = 1;
		FAIL_INSUFFICIENT_FUNDS = 2;
		FAIL_OTHER = 3;
	}
}

